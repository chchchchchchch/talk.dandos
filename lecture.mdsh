SITUATED SOFTWARES
==================

% INTRODUCTION

My first experience with code to create something visual
was through making HTML pages. WYSIWYG editors[^]{in my case MicrosoftTM
FrontpageTM on Windows NT} where quite bad at this time.
So even for somebody having no clue
opening your HTML page in a text editor and edit
the source code manually was a valuable alternative.
There were a lot of resources to learn about the basics, the rest could
come 'learning by doing'.
At the same time I adjusted to a procedure
that is quite common for a lot of digital workflows,
from writing code to doing animation:

DO, WAIT, JUDGE. (DO AGAIN.)

DO: make (or make changes to) something
WAIT: until the computer processed your input
JUDGE: see the result

Getting used to this iterative cycles from very early on,
is maybe the reason why
I had lower expectations regarding some kind of _'real-time' WYSIWYG_ experience
_'Real-time' WYSIWYG_
in the sense of '_create things (exactly) as they will be_'.
Thinking about animation, I'm actually quite curious what this could be.

Through HTML I also experienced another culture.
With HTML the source code always was just one mouseclick away.
Rightclick -> 'Quelltext anzeigen' and see how things work.
Consequently my first annoying experience with proprietary
mentality was Flash. While being a quite inspirational application
to create graphics for the web it also introduced
'locking things up' in an environment were the availabilty of
source code was formerly a standard.

Some years later, around 2007, I got introduced to GNU/Linux and
'Unix Culture' and that's were my interest in tinkering and code
expanded. 

I had a quite rough initiation to GNU/Linux by renting
our own webserver in a 'Rechenzentrum'. I got talked into
this by a colleague and as I was not in general against the idea
of self-empowerment we just did it. I barely touched
Free Software before, but my colleague insisted that he'd know
what he is doing. (Today I've serious doubts about that.)
Anyway we now had a computer somewhere at a remote location,
accessible only over terminal and making fundamental mistakes
meant to call someone in the 'Rechenzentrum' and ask them to
reboot your machine. In retrospect this harsh take-off had
the effect that I had different expectations (and maybe different dissapointments).
Different than what seems obvious if you install a GNU/Linux Distribution as
a replacement for OSX and want it to 'just work alike'.

My second introduction came from another direction and was 
a bit less abrupt but at least as inspiring.
At the audio department of the KHM Martin Rumori
had set up a series of 'angebote' around the culture and
cult of Unix and GNU/Linux and free software in general.
It is within this bigger context where first major project
in the field of f/l/os graphic design came into being.


% PERSONAL SOFTWARE

In 2007 I developed the key visual
for the _Linux Audio Conference_, a annual conference of Linux
Audio Developers, that was hosted at the KHM in early 2008.
The them' was hyperconnective machine/instrument/environment,
which was very much inspired by the idea that 
users are encouraged to think and make their own applications
... (Cramer Quote, LISL)
Wether or not this seems to make sense and maybe better if not.
'prevent users from doing ...'

The graphics were automatically generated from a pool of modular
illustrations producing not one image, but approaching/get to feel
the diversity based on this modular system.

The following years brought more graphic design projects all
more or less connected through the idea:

_design rules to design poster
 instead of
 design posters_

% MAKE ART
% LAC 2009

These projects were all closely connected to f/l/os culture:

1. made for f/l/os initiatives
2. using f/l/os software only
3. being f/l/os themselves

While published under f/l/os licenses I actually never expected
anyone to reuse these projects 'as is'. Why? The software within 
these projects is very specific. Although the source code is
available, it is nothing to just download, install and run.
As far as I know. It is not written for some generic use and user,
but for a very specific. In this way it is really _personal software_.

And to be honest: it was never my ambition to create general-purpose software.
The intention is to have an example, that helps to imagine what
could be possible. Not to have 'just another' convenient solution.
So this is the exciting part for me: make and experience and
show interesting possibilities beside the mononculture we're used
to when it comes to digital design tools.


% TOWARDS SITUATED SOFTWARE

2012 I worked on a project for the Libre Graphics Meeting 2013
at Medialab Prado. The brief was to create a visual identity for
the meeting, which would reflect and capture voices of the community.
We developed a simple interface, where people could ask or answer questions.
These conversations were collected and used to generate posters.




In 2014 I started together with Constant from Brussels to make
a book of interviews. The interviews were made by Constant,
over a period of 10 years, all connected to the subject of Libre Graphics. 
For the book we had the ambition
to create a setup that would work different from the workflows we were used to.
This means different from a standard editorial process, were design has to happen
after everything else
is finished.
The content is edited collaboratively online, written as a lightweight
markup language. Content is pulled into a 'local software setup'
where a pdf file (ready to print) is generated. The 'local setup'
could be installed on any standard GNU/Linux computer (even OSX worked).

Contributing to the editing was as easy as opening a website and
also the installation of the software was feasible. I must admit
that in the end I was quite happy with the setup, that allowed
contributions through a lot of different layers and complexities,
from proofreading to replicating the whole infrastructure.

The last 2 projects are different from my earlier work.
They're not completely automated processes anymore,
but they provide some sort of easy-to-use interface.
This non-generic, temporary,
maybe over-specific form of interaction is,
for me,
right now,
a very interesting space.
Develop interfaces for specific uses
that explicitely ignore the myriad of things
that might be also interesting.

% Bernhard word Scherzbild
% non-distracting writer




SITUATED SOFTWARE ?
-------------------

> [...] situativity theorists suggest
> a model of knowledge and learning
> that requires thinking on the fly
> rather than the storage and retrieval
> of conceptual knowledge.
> [*](http://en.wikipedia.org/wiki/Situated_cognition)

_a model of software 
 that requires making on the fly
 rather than the storage and retrieval
 of generic software._

f/l/os has long tradition and experience to empower
reuse and adaptibility. And not as some cosmetic correction
but through all layers of complexity, from its interfaces
to its very inner workings. The option to redefine a piece
of software is also fundamental to my idea of 'situated
softwares'. I like the idea of minimal, _situated interfaces_.
But if the interface is all that is accessible, this
is not a good idea. 

There's an important difference
between hiding and making inaccessible.
% esr taoup p.151


% situated softwares allow all the 'bad practises'
% my break all the 'good intention' 
% oversimplification, hardwiring, instability, ...
% This is possible as the 'situated software' does 
% neither need to work for everybody and nor
% endure the rest of time.
% 'situated software' may be anything from a small
% script to rename your files to a collaborative 
% writing setup.



I'd like to close with an 'everyday' example of a
'something situated'. It is a markup dialect based on
the widespread standard markdown but allows to extend this standard 
with custom 'instructions'. These 'instructions' are
simple lines of text that allow to perform specific actions
when translating the source code to some other format.

It is situated as it was developed for a specific
group, at a specific time, for a specific task.
The 'instructions' are not predefined but may be
developed on-the-fly. And last but not least it is
situated once more as the definition of 'instructions'
explicitely happen in the local context of the transformer.
 









----

EXPLAIN (?)

- HTML
- WYSIWYG
- GNU/Linux



Maybe it's also adapting to reality as I realised that there
are many people that are not motivated to use a swiss army knife
to make breakfast. But there are situations were the swiss
army knife really makes sense. 

